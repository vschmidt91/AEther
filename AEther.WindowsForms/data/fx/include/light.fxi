
#define Extinction (Scattering + Absorption)

cbuffer LightConstants : register(b2)
{
	float4x4 LightView;
	float4x4 LightProjection;
    float3 LightIntensity;
	float Anisotropy;
    float3 LightPosition;
	float LightDistance;
    float3 Emission;
	float ShadowFarPlane;
    float3 Scattering;
    float3 Absorption;
};

#ifndef PI
#define PI 3.14159
#endif

#define fatan(x)  ((x) / (1 + .28125 * (x) * (x)))
#define fatan2(y, x) ((x) * (y) / ((x) * (x) + .28125 * (y) * (y)))
#define fatan3(y, x) lerp(sign(y) * PI / 2 - fatan2(y, x), fatan2(x, y), abs(y) >)

#define AngleToParameter(D, theta) ((D) * tan(theta))
#define ParameterToAngle(D, t) atan2((t), (D))

#define LightSamplePDF(theta0, theta1, D, t) ((D) / ((theta1 - theta0) * ((D) * (D)  + (t) * (t))))
#define LightSampleCDFinv(theta0, theta1, D, p) (AngleToParameter(D, lerp(theta0, theta1, p)))

#define ExtinctionSamplePDF(T, t) (Extinction.r * exp(-Extinction.r * (t)) / (1 - exp(-Extinction.r * (T))))
#define ExtinctionSampleCDF(T, t) ((1 - exp(-Extinction.r * (t))) / (1 - exp(-Extinction.r * (T))))
#define ExtinctionSampleCDFinv(T, p) (-log(lerp(1, exp(-Extinction.r * (T)), (p))) / Extinction.r)
//#define DistanceSample(T, p) (-log(lerp(1, exp(-Extinction.r * (T)), (p))) / Extinction.r)

#define ThetaMax (PI / 2)
#define SampleOffset float4(0, .25, .5, .75)

SamplerState Airlight_LookupSampler
{
	Filter = MIN_MAG_MIP_LINEAR;
};

float PhaseHG(float cosTheta, float g)
{
	float g2 = g * g;
	float d = 1 + g2 - 2 * g * cosTheta;
	return (1 - g2) * rsqrt(d * d * d) / (4 * PI);
}

float4 PhaseHG4(float4 cosTheta, float g)
{
	float4 g2 = g * g;
	float4 d = 1 + g2 - 2 * g * cosTheta;
	return (1 - g2) * rsqrt(d * d * d) / (4 * PI);
}

float3 Airlight(float theta, float d, int numSamples)
{

	float3 Lv = 0;

	for (int i = 0; i < numSamples; ++i)
	{

		float4 p = (i + SampleOffset) / numSamples;
		float4 thetas = lerp(theta, ThetaMax, p);
		float4 ts = AngleToParameter(d, thetas);
		float4 phase = PhaseHG4(sin(thetas), Anisotropy);
		float4 depths = sqrt(d * d + ts * ts) + ts;

		[unroll(4)]
		for (int j = 0; j < 4; ++j)
		{
			Lv += phase[j] * exp(-depths[j] * Extinction.rgb);
		}

	}

	return Lv * (ThetaMax - theta) / (4 * numSamples);

}

float LineAngle(float3 p, float3 d, float3 x, float3 y)
{

	float3 px = cross(d, x - p);
	float3 py = normalize(cross(d, y - p));
	float3 pyp = cross(d, py);

	return atan2(dot(px, py), dot(px, pyp));

}

float LineDistance(float3 p, float3 d, float3 x)
{
	return length(cross(d, x - p));
}