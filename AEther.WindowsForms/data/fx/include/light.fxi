
#define Extinction (Scattering + Absorption)

cbuffer LightConstants : register(b2)
{
	float4x4 LightTransform;
    float3 LightIntensity;
	float Anisotropy;
    float3 LightPositionOrDirection;
	float LightDistance;
    float3 Emission;
    float3 Scattering;
    float3 Absorption;
};

#ifndef PI
#define PI 3.14159
#endif

#define fatan(x)  x / (1 + .28125 * x * x)
#define fatan2(y, x) (x * y / (x * x + .28125 * y * y))
#define fatan3(y, x) lerp(sign(y) * PI / 2 - fatan2(y, x), fatan2(x, y), abs(y) >)

#define AngleToParameter(D, theta) (D * tan(theta))
#define ParameterToAngle(D, t) atan2(t, D)

#define LightSamplePDF(theta0, theta1, D, t) (D / ((theta1 - theta0) * (D * D  + t * t)))
#define LightSampleCDFinv(theta0, theta1, D, p) (AngleToParameter(D, lerp(theta0, theta1, p)))

#define DistanceSample(t, p) (-log(lerp(1, exp(-Extinction.r * t), p)) / Extinction.r)

#define ThetaMax (PI / 2)
#define SampleOffset float4(0, .25, .5, .75)

SamplerState Airlight_LookupSampler
{
	Filter = MIN_MAG_MIP_LINEAR;
};

float PhaseHG(float cosTheta, float g)
{
	float g2 = g * g;
	float d = 1 + g2 - 2 * g * cosTheta;
	return (1 - g2) * rsqrt(d * d * d) / (4 * PI);
}

float4 PhaseHG4(float4 cosTheta, float g)
{
	float4 g2 = g * g;
	float4 d = 1 + g2 - 2 * g * cosTheta;
	return (1 - g2) * rsqrt(d * d * d) / (4 * PI);
}

float3 Airlight(float theta, float d, int numSamples)
{

	float3 Lv = 0;

	for (int i = 0; i < numSamples; ++i)
	{

		float4 p = (i + SampleOffset) / numSamples;
		float4 thetas = lerp(theta, ThetaMax, p);
		float4 ts = AngleToParameter(d, thetas);
		float4 phase = PhaseHG4(sin(thetas), Anisotropy);
		float4 depths = sqrt(d * d + ts * ts) + ts;

		[unroll(4)]
		for (int j = 0; j < 4; ++j)
		{
			Lv += phase[j] * exp(-depths[j] * Extinction.rgb);
		}

	}

	return Lv * (ThetaMax - theta) / (4 * numSamples);

}

float LineAngle(float3 p, float3 d, float3 x, float3 y)
{

	float3 px = cross(d, x - p);
	float3 py = normalize(cross(d, y - p));
	float3 pyp = cross(d, py);

	return atan2(dot(px, py), dot(px, pyp));

}

float LineDistance(float3 p, float3 d, float3 x)
{
	return length(cross(d, x - p));
}


float3 RectifyPointLight(float3 v, float depth)
{

	float3 lightPos = mul((float3x3)LightTransform, v);
	float3 lightPosShifted = depth * lightPos + float3(0, 0, LightDistance);

	float3 rect = 0;	

	rect.x = -1 + 2 * acos(normalize(lightPosShifted).z) / PI;
	rect.y = atan2(lightPos.y, lightPos.x) / PI;
	rect.z = acos(-lightPos.z) / PI;

	return rect;

}

float3 RectifyDirectionalLight(float3 v, float depth, float farPlane)
{

	float3 lightPos = mul((float3x3)LightTransform, v);

	float3 rect = 0;
	rect.x = -1 + 2 * length(lightPos.xy) * depth / farPlane;
	rect.y = atan2(lightPos.y, lightPos.x) / PI;
	rect.z = acos(-lightPos.z) / PI;
	return rect;

}

float PSM(float b, float depth)
{
	return depth - 1e-3 < b;
} 

float VSM(float2 b, float z)
{
	b = lerp(b, 0, 1e-5);
	z -= 1e-5;
	float variance = b[1] - b[0] * b[0];
	float d = b[0] - z;
	return saturate(max(variance / (variance + d * d), z <= b[0]));
} 